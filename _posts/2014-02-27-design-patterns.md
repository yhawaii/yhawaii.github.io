---
layout: post
keywords: "设计模式学习笔记"
description: "设计模式学习笔记 "
title: "设计模式学习笔记 "
categories: [设计模式]
tags: [设计模式]
group: archive
icon: file-alt
---
{% include site/setup %}

# 设计模式

23种设计模式助记口诀：

桥适组装 外享代

职解状中备，观命策模访 迭

6大设计原则助记口诀: 开迪(的)接里(林)单


##一、 简介

### 设计模式四境界：

* 没学之前，想不到使用设计模式，设计的代码很糟糕
* 学了设计模式后，很开心，到处使用学过的模式，造成无用而不自知；
* 学完全部模式时，感觉诸多模式极其相似，无法分清模式直接的差异，有困惑，但深知误用之害，应用之时有所犹豫。
* 灵活应用模式，深知不应用具体的某种模式也能设计出非常优秀的代码，到达无剑胜有剑的境界。


## 二、 软件设计6大原则

###  1、单一职责原则(SRP)

###  2、里氏替换原则(LSP)


###  3、依赖倒置原则：
抽象不应该依赖细节，细节应该依赖抽象，说到底，就是要针对借口编程，不要对实现编程。

依赖倒置包含2个方面:
1. 高层模块不应该依赖底层模块，2个都应该依赖抽象
2. 抽象不应该依赖细节。细节应该依赖抽象

###  4、接口隔离原则

###  5、迪米特法则（LoD）
也叫最少知识原则。
如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另外一个类的某个方法的话，可以通过第三者转发这个调用。
迪米特法则的根本思想，是强调类之间的松耦合


###  6、开闭原则(ASD)： 

## 三、 23种设计模式概述：


23种设计模式

简单工厂（不属于23中设计模式）:
工厂类中包含了必要的逻辑判断，根据客户的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。
假如要添加新的工厂，则需要修改工厂类，这样就违背了开放封闭原则。

### 学习设计模式的关注点

学习设计模式的关注点：

a、概念。     正常不使用的弊端（提出问题）

b、使用的优点

c、UML图

d、demo代码（以为懂了，但是写不出代码，说明你是假懂）

e、反复思考，举例印证

##四、创建型模式(5种)

### 1. 工厂方法模式：


a、定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到子类。

b、

UML图：
![](http://yhawaii.github.io/assets/themes/yhawaii/images/DesignPatterns/factory_method.png)
### 2.建造者模式：

a、需要将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示的意图时，我们就可以考虑使用构造者模式。

如果我们用了建造者模式，那么用户就只需指定需要建造的类型就可以得到它们，而具体建造的过程和细节就不需知道了。

定义：建造者模式，将一个复杂对象的构建和它的表示分离，使得同样的构建过程可以创建不同的表示。


b、使得建造代码与表示代码分离，由于创建者隐藏了该产品是如何组装的，所以若需要改变一个产品的内部表示，只需要再定义一个具体的建造者就可以了。

UML图：
![](http://yhawaii.github.io/assets/themes/yhawaii/images/DesignPatterns/builder.png)
### 3.抽象工厂模式

UML图：
![](http://yhawaii.github.io/assets/themes/yhawaii/images/DesignPatterns/abstract_factory.png)

### 4.原型模式：

UML图：
![](http://yhawaii.github.io/assets/themes/yhawaii/images/DesignPatterns/prototype.png)

### 5.单例模式

## 五、结构型模式(7种)

### 1.适配器模式(Adapter)
UML图：
![](http://yhawaii.github.io/assets/themes/yhawaii/images/DesignPatterns/adapter.png)

### 2.桥接模式(Bridge)

a、意图

b、动机
当一个抽象可能有多个实现时,通常用继承来协调它们。抽象类定义对该抽象的接口,而具体的子类则用不同方式加以实现。但是此方法有时不够灵活。继承机制将抽象部分与它 的实现部分固定在一起,使得难以对抽象部分和实现部分独立地进行修改、扩充和重用。


c、适用性
以下一些情况使用Bridge模式:* 你不希望在抽象和它的实现部分之间有一个固定的绑定关系。例如这种情况可能是因为,在程序运行时刻实现部分应可以被选择或者切换。
* 类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。这时Bridge模式使你可以对不同的抽象接口和实现部分进行组合,并分别对它们进行扩充。
* 对一个抽象的实现部分的修改应对客户不产生影响,即客户的代码不必重新编译。
* (C++)你想对客户完全隐藏抽象的实现部分。在C++中,类的表示在类接口中是可见的。
* 正如在意图一节的第一个类图中所示的那样,有许多类要生成。这样一种类层次结构说明你必须将一个对象分解成两个部分。Rumbaugh称这种类层次结构为“嵌套的普化”(nestedgeneralizations)。
* 你想在多个对象间共享实现(可能使用引用计数),但同时要求客户并不知道这一点。一个简单的例子便是Coplien的String类[Cop92],在这个类中多个对象可以共享同一个字符串表示(StringRep)。
桥接模式：将抽象部分和它的实现部分分离，使它们都可以独立地变化。


什么叫做抽象与它的实现分离，这不是说，让抽象类与其派生类分离，因为这没有任何意义。实现指的是抽象类和它的派生类来实现自己的对象。

在发现我们需要多角度去分类实现对象，而且用继承会造成大量的类增加，不能满足开放-封闭原则时，就应该考虑用桥接模式了。

UML图：
![](http://yhawaii.github.io/assets/themes/yhawaii/images/DesignPatterns/bridge.png)
### 3.组合模式(Composite)
1.意图将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性。

2.适用性以下情况使用Composite模式:* 你想表示对象的部分-整体层次结构。* 你希望用户忽略组合对象与单个对象的不同,用户将统一地使用组合结构中的所有对象。
3.效果* 定义了包含基本对象和组合对象的类层次结构基本对象可以被组合成更复杂的组合对象,而这个组合对象又可以被组合,这样不断的递归下去。客户代码中,任何用到基本对象的地方都可以使用组合对象。* 简化客户代码客户可以一致地使用组合结构和单个对象。通常用户不知道(也不关心)处理的是一个叶节点还是一个组合组件。这就简化了客户代码,因为在定义组合的那些类中不需要写一些充斥着选择语句的函数。* 使得更容易增加新类型的组件新定义的Composite或Leaf子类自动地与已有的结构和客户代码一起工作,客户程序不需因新的Component类而改变。* 使你的设计变得更加一般化容易增加新组件也会产生一些问题,那就是很难限制组合中的组件。有时你希望一个组合只能有某些特定的组件。使用Composite时,你不能依赖类型系统施加这些约束,而必须在运行时刻进行检查。

UML图：
![](http://yhawaii.github.io/assets/themes/yhawaii/images/DesignPatterns/composite.png)
### 4.装饰模式(Decorator)

**from gof**<br />
a、意图动态地给一个对象添加一些额外的职责。就增加功能来说, 更为灵活。
b、动机
有时我们希望给某个对象而不是整个类添加一些功能。例如,一个图形用户界面工具箱允许你对任意一个用户界面组件添加一些特性,例如边框,或是一些行为,例如窗口滚动。 使用继承机制是添加功能的一种有效途径,从其他类继承过来的边框特性可以被多个子 类的实例所使用。但这种方法不够灵活,因为边框的选择是静态的,用户不能控制对组件加边框的方式和时机。 一种较为灵活的方式是将组件嵌入另一个对象中,由这个对象添加边框。我们称这个嵌入的对象为 装饰 。这个装饰与它所装饰的组件接口一致,因此它对使用该组件的客户透明。 它将客户请求转发给该组件,并且可能在转发前后执行一些额外的动作(例如画一个边框)。 透明性使得你可以递归的嵌套多个装饰,从而可以添加任意多的功能

c、适用性以下情况使用Decorator模式* 在不影响其他对象的情况下,以动态、透明的方式给单个对象添加职责。* 处理那些可以撤消的职责。* 当不能采用生成子类的方法进行扩充时。一种情况是,可能有大量独立的扩展,为支持每一种组合将产生大量的子类,使得子类数目呈爆炸性增长。另一种情况可能是因为类定义被隐藏,或类定义不能用于生成子类。

d、效果
Decorator模式至少有两个主要优点和两个缺点:
1)比静态继承更灵活与对象的静态继承(多重继承)相比,Decorator模式提供了更加灵活的向对象添加职责的方式。可以用添加和分离的方法,用装饰在运行时刻增加和删除职责。相比之下,继承机制要求为每个添加的职责创建一个新的子类(例如,BorderScrollableTextView,BorderedTextView)。这会产生许多新的类,并且会增加系统的复杂度。此外,为一个特定的Component类提供多个不同的Decorator类,这就使得你可以对一些职责进行混合和匹配。使用Decorator模式可以很容易地重复添加一个特性,例如在TextView上添加双边框时,仅需将添加两个BorderDecorator即可。而两次继承Border类则极容易出错的。
2)避免在层次结构高层的类有太多的特征Decorator模式提供了一种“即用即付”的方法来添加职责。它并不试图在一个复杂的可定制的类中支持所有可预见的特征,相反,你可以定义一个简单的类,并且用Decorator类给它逐渐地添加功能。可以从简单的部件组合出复杂的功能。这样,应用程序不必为不需要的特征付出代价。同时也更易于不依赖于Decorator所扩展(甚至是不可预知的扩展)的类而独立地定义新类型的Decorator。扩展一个复杂类的时候,很可能会暴露与添加的职责无关的细节。
3)Decorator与它的Component不一样Decorator是一个透明的包装。如果我们从对象标识的观点出发,一个被装饰了的组件与这个组件是有差别的,因此,使用装饰时不应该依赖对象标识。
4)有许多小对象采用Decorator模式进行系统设计往往会产生许多看上去类似的小对象,这些对象仅仅在他们相互连接的方式上有所不同,而不是它们的类或是它们的属性值有所不同。尽管对于那些了解这些系统的人来说,很容易对它们进行定制,但是很难学习这些系统,排错也很困难。

**from 大话**<br />
a、当系统中需要新功能的时候，是向旧的类中添加新代码。这些新的代码通常装饰了原有类的核心职责或主要行为。但这种作法的问题在于，它们在主类中加入了新的字段，新的方法和新的逻辑



b、动态给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。
把类中的装饰功能从类中搬移去除，这样可以简化原有的类，有效的把类的核心职责和装饰功能区分开了。而且可以去除相关类中重复的逻辑。

c、UML图
Component是定义一个对象接口，可以给这些对象动态添加职责。ConcreteComponent是定义了一个具体的对象，也可以给这个对象添加一些职责。Decorator，装饰抽象类，继承了Component，从外类来扩展Component类的功能，但对应Component来说，是无需知道Decorator的存在的，至于ConcreteDecorator就是具体的装饰对象，起到给Component添加职责的功能。

UML图：
![](http://yhawaii.github.io/assets/themes/yhawaii/images/DesignPatterns/decorator.png)

###5.外观模式(Facade)
**from gof**

a、意图
为子系统中的一组接口提供一个一致的界面,Facade模式定义了一个高层接口,这个接口使得这一子系统更加容易使用。b、适用性
在遇到以下情况使用Facade模式* 当你要为一个复杂子系统提供一个简单接口时。子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类。这使得子系统更具可重用性,也更容易对子系统进行定制,但这也给那些不需要定制子系统的用户带来一些使用上的困难。Facade可以提供一个简单的缺省视图,这一视图对大多数用户来说已经足够,而那些需要更多的可定制性的用户可以越过facade层。
* 客户程序与抽象类的实现部分之间存在着很大的依赖性。引入facade将这个子系统与客户以及其他的子系统分离,可以提高子系统的独立性和可移植性。* 当你需要构建一个层次结构的子系统时,使用facade模式定义子系统中每层的入口点。如果子系统之间是相互依赖的,你可以让它们仅通过之间的依赖关系。

**from 大话**
为子系统的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更容易使用。 父类需要了解所有的子系统的方法和属性，进行组合，以备外界调用。


> 外观模式在什么时候使用最好呢？

这要分三个阶段来说：

1. 首先，在设计初期，应该要有意识的将不同的2各层分离，比如经典的三层架构，就需要考虑在数据访问层和业务逻辑层、业务逻辑层和表示层的层与层之间建立外观模式，这样可以为复杂的子系统提供一个简单的接口，使得耦合大大降低。
2. 其次，在开发阶段，子系统往往因为不断的重构演化而变得越来越复杂，大多数的模式使用时也会产生很多很小的类，这是好事，但也给外部调用他们的用户程序带来使用上的困难，**增加外观模式可以提供一个简单的接口，减少它们之间的依赖**
3. 第三，在维和一个遗留的大型系统时，可能这个系统已经非常难以维护和扩展了，但因为他包含非常重要的功能，新的需求开发必须依赖于它。此时外观模式也是非常适合的。


UML图：
![](http://yhawaii.github.io/assets/themes/yhawaii/images/DesignPatterns/facade.png)
### 6.享元模式(flyweight)

运用共享技术有效地支持大量细粒度对象。

a、 意图运用共享技术有效地支持大量细粒度的对象。
b、适用性
Flyweight模式的有效性很大程度上取决于如何使用它以及在何处使用它。当以下情况都成立时使用Flyweight模式:
* 一个应用程序使用了大量的对象。* 完全由于使用大量的对象,造成很大的存储开销。* 对象的大多数状态都可变为外部状态。* 如果删除对象的外部状态,那么可以用相对较少的共享对象取代很多组对象。* 应用程序不依赖于对象标识,因为对象不能提供唯一的标识。由于Flyweight对象可以被共享,对于概念上明显有别的对象,标识测试将返回真值。

c、效果
   使用Flyweight模式时,传输、查找和/或计算外部状态都会产生运行时的开销,尤其当flyweight原先被存储为内部状态时。然而,空间上的节省抵消了这些开销。共享的flyweight越多,空间节省也就越大。存储节约由以下几个因素决定:

* 因为共享,实例总数减少的数目* 对象内部状态的平均数目
* 外部状态是计算的还是存储的
共享的Flyweight越多,存储节约也就越多。节约量随着共享状态的增多而增大。当对象使用大量的内部及外部状态,并且外部状态是计算出来的而非存储的时候,节约量将达到最大。所以,可以用两种方法来节约存储:用共享减少内部状态的消耗,用计算时间换取对外部状态的存储。Flyweight模式经常和Composite模式结合起来表示一个层次式结构,这一层次式结构是一个共享叶节点的图。共享的结果是,Flyweight的叶节点不能存储指向父节点的指针。而父节点的指针将传给Flyweight作为它的外部状态的一部分。这对于该层次结构中对象之间相互通讯的方式将产生很大的影响。
UML图：
![](http://yhawaii.github.io/assets/themes/yhawaii/images/DesignPatterns/flyweight.png)

### 7.代理模式(Proxy)

Cocoa touch框架中使用代理模式的例子：
NSProxy类

a、意图
为其他对象提供一种代理以控制对这个对象的访问。

**from 大话**

a、为其他对象提供一种代理以控制对这个对象的方法。

b、适用性在需要用比较通用和复杂的对象指针代替简单的指针的时候,使用些可以使用Proxy模式常见情况:Proxy模式。下面是一些可以使用Proxy模式常见情况:1)远程代理(Remote Proxy)为一个对象在不同的地址空间提供局部代表。NEXTSTEP[Add94]使用NXProxy类实现了这一目的。Coplien[Cop92]称这种代理为“大使”(Ambassador)。
2)虚代理(Virtual Proxy)根据需要创建开销很大的对象。浏览器打开网页，包含大量图片和文字的html文档的时候，却可以快速打开。
3)保护代理(Protection Proxy)控制对原始对象的访问。保护代理用于对象应该有不同的访问权限的时候。例如,在Choices操作系统[CIRM93]中KemelProxies为操作系统对象提供了访问保护。
4)智能指引(Smart Reference)取代了简单的指针,它在访问对象时执行一些附加操作。它的典型用途包括:* 对指向实际对象的引用计数,这样当该对象没有引用时,可以自动释放它(也称为SmartPointers[Ede92])。
* 当第一次引用一个持久对象时,将它装入内存。* 在访问一个实际对象前,检查是否已经锁定了它,以确保其他对象不能改变它。

> 代理模式的使用场合：

1.  远程代理。webservice
2.  虚拟代理。
3.  安全代理


c、UML图如下：

![](http://yhawaii.github.io/assets/themes/yhawaii/images/DesignPatterns/proxy.png)
##六、行为模式(11种)

>	行为模式涉及到算法和对象间职责的分配。行为模式不仅描述对象或类的模式,还描述它们之间的通信模式。这些模式刻划了在运行时难以跟踪的复杂的控制流。它们将你的注意力从控制流转移到对象间的联系方式上来。<br /><br />行为类模式使用继承机制在类间分派行为。包括两个这样的模式。其中Template Method较为简单和常用。模板方法是一个算法的抽象定义,它逐步地定义该算法,每一步调用一个抽象操作或一个原语操作,子类定义抽象操作以具体实现该算法。另一种行为类模式是Interpreter。它将一个文法表示为一个类层次,并实现一个解释器作为这些类的实例上的一个操作。<br /><br />行为对象模式使用对象复合而不是继承。一些行为对象模式描述了一组对等的对象怎样相互协作以完成其中任一个对象都无法单独完成的任务。这里一个重要的问题是对等的对象如何互相了解对方。对等对象可以保持显式的对对方的引用,但那会增加它们的耦合度。在极端情况下,每一个对象都要了解所有其他的对象。Mediator在对等对象间引入一个mediator对象以避免这种情况的出现。mediator提供了松耦合所需的间接性。<br /><br />	Chain of Responsibility 提供更松的耦合。它让你通过一条候选对象链隐式的向一个对象发送请求。根据运行时刻情况任一候选者都可以响应相应的请求。候选者的数目是任意的,你可以在运行时刻决定哪些候选者参与到链中。<br /><br />
	Observer 模式定义并保持对象间的依赖关系。典型的Observer的例子是Smalltalk中的模型/视图/控制器,其中一旦模型的状态发生变化,模型的所有视图都会得到通知。<br />
	<br />其他的行为对象模式常将行为封装在一个对象中并将请求指派给它。Strategy模式将算法封装在对象中,这样可以方便地指定和改变一个对象所使用的算法。Command 模式将请求封装在对象中,这样它就可作为参数来传递,也可以被存储在历史列表里,或者以其他方式使用。State模式封装一个对象的状态,使得当这个对象的状态对象变化时,该对象可改变它的行为。Visitor封装分布于多个类之间的行为,而Iterator则抽象了访问和遍历一个集合中的对象的方式。

### 1.职责链模式(Chain of Resposibility)

a、 意图
使多个对象都有机会处理请求,从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链,并沿着这条链传递该请求,直到有一个对象处理它为止。 这里发出这个请求的客户端并不知道这当中的哪一个对象最终处理这个请求，这样系统的更改可以在不影响客户端的情况下动态地重新组织和分配责任。b、 适用性

在以下条件下使用Responsibility 链:* 有多个的对象可以处理一个请求,哪个对象处理该请求运行时刻自动确定。 
* 你想在不明确指定接收者的情况下,向多个对象中的一个提交一个请求。* 可处理一个请求的对象集合应被动态指定。
c、效果
职责链有下列优点和缺点：
1） 降低耦合度，该模式使得一个对象无需知道是其他哪一个对象处理其请求。对象仅需知道改请求会被“正确“”的处理。接受者和发送者都没有对方的明确的信息，且链中的对象不需知道链的结构。
结果是，指责链可简化对象的相互连接。它们仅需保持一个指向其后继的引用，而不需保持它所有的候选者的引用
2）增强了给对象指派职责的灵活性
3）不保证被接受
UML图：
![](http://yhawaii.github.io/assets/themes/yhawaii/images/DesignPatterns/responsibility.png)
### 2.命令模式(Command)

eg：浏览器的前进/后退；数据库的事务操作，画图时的重做和撤消。

Cocoa touch框架中命令模式的使用：
NSUndoManager(对应的设计模式命令对象NSInvocation)和"Target-Action"机制是框架中对这个模式的经典应用。
a、意图
将一个请求封装为一个对象，从而使你可用不同的请求对客户端进行参数化；对请求排队或记录请求日志，以及支持可撤消的操作。
b、适用性
当你有如下需求时，可用命令模式:
* 抽象出待执行的动作以参数化某对象。你可用过程语言中的回调(callback)函数表达这种参数化机制。所谓回调函数是指函数先在某处注册，而它将在稍后某个需要的时候被调用。command模式是回调机制的一个面相对象的替代品
* 在不同的时刻指定、排列和执行请求。一个command对象可以有一个与初始请求无关的生存期。如果一个请求的接收者可用一种与地址空间无关的方式表达，那么就可将负责该请求的命令对象传送给另一个不同的进程并在那儿实现该请求。
* 支持取消操作。command呃excute操作可在实施操作之前将状态存储起来，在取消操作时这个状态用来取消该操作的影响。执行的命令被存储在一个历史列表中。可通过向后和向前遍历这一列表并分别调用unexcute和excute来实现重数不限的“取消”和“重做”。
* 支持修改日志，这样当系统崩溃时，这些修改可以被重做一遍。
* 用构建在原语操作上的高层操作构造一个系统。这样一种结构在支持事务的信息系统中很常见。一个事务封装了对数据的一组变动。c、效果
command模式有以下效果：
1）command模式将调用操作的对象与知道如何实现该操作的对象解耦
2）command是头等的对象，他们可像其它的对象一样被操作和扩展
3）你可将多个命令装配成一个符合命令。一般来说，符合命令是composite模式的一个实例。
4）增加新的command很容易，因为这无需改变已有的类。UML图：
![](http://yhawaii.github.io/assets/themes/yhawaii/images/DesignPatterns/command.png)

### 3.解释器模式(Interpreter)

a、意图

给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。

b、动机

如果一种特定类型的问题发生的频率足够高，那么可能就值得将该问题的各个实例表述为一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。

c、适用性

当有一个语言需要解释执行，并且你可将该语言中的句子表示为一个抽象语法树时，可使用解释器模式。而当存在以下情况时该模式效果最好：

* 该文法简单对于复杂的文法，文法的类层次变得庞大而无法管理。此时词法分析程序生成器这样的工具是更好的选择。它们无需构建抽象语法树即可解释表达式，这样可以节省空间而且还可能节省时间。
* 效率不是一个关键问题最高效的解释器通常不是通过直接解释语法分析树实现的，而是首先将它们转换成另一种形式。例如，正则表达式通常被转换成状态机。但即使在这种情况下，转换器仍可用解释器模式实现，该模式仍是有用的。

UML图：
![](http://yhawaii.github.io/assets/themes/yhawaii/images/DesignPatterns/interpreter.png)

### 4.迭代器模式(Iterator)

### 5.中介者(Meditor)
UML图：
![](http://yhawaii.github.io/assets/themes/yhawaii/images/DesignPatterns/mediator.png)

### 6.备忘录(Memento)
a、在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该对象恢复到原先保存的状态。

UML图：
![](http://yhawaii.github.io/assets/themes/yhawaii/images/DesignPatterns/memento.png)

### 7.观察者(Observer)
a、观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象，这个主题对象在状态发生变化时，会通知所以观察者对象，使它们能够自动更新自己。


UML图：
![](http://yhawaii.github.io/assets/themes/yhawaii/images/DesignPatterns/observer.png)

### 8.状态模式(State)
a、当一个对象的内在状态改变时，允许改变其行为，这个对象看起来像是改变了其类。
不使用时的缺点：当判断分支特别多的时候，导致方法过长，并且任何需求的变动或者增加，都需要去更改这个方法的时候，导致出错的风险增大，就应该考虑状态模式了。

b、状态模式主要解决的是当控制一个对象的状态转换的条件表达式过于复杂时的情况。当状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。通过定义新的子类，可以很容易的增加新的状态和转换。说明了转移做就是为了消除庞大的条件分支语句。状态模式通过把各种状态转移逻辑分布到State的子类之间，来减少相互依赖。


UML图：
![](http://yhawaii.github.io/assets/themes/yhawaii/images/DesignPatterns/state.png)

### 9.策略模式
a、算法本身只是一种策略，最重要的是算法随时都可能被替换，这就是变化，而封装变化点是面向对象的一种重要.

b、策略模式是一种定义一系列算法的方法，从概念上来看，所以这些算法完成的都是相同的工作，只是实现不同，它可以以相同的方式调用所有的算法，减少了各种算法类与使用算法类之间的耦合。
策略模式的Strategy类层次为context定义了一系列的可供充裕的算法或行为。继承有助于析取出这些算法中的公共功能。
简化了单元测试，因为每个算法都有自己的类，可以通过自己的接口单独测试。

c、UML图如下：
![](http://yhawaii.github.io/assets/themes/yhawaii/images/DesignPatterns/strategy.png)

### 10.模板方法(Template Method)
a、定义一个操作中的算法的骨架，而将一些不再延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可冲定义改算法的某些特定步骤。

当我们要完成在某一细节层次一致的一个过程或一系列步骤，但其个别步骤在更详细的层次上的实现可能不同时，我们通常考虑用模板方法来处理。

b、模板方法模式是通过把不变行为搬移到父类，去除子类中的重复代码来体现它的优势。

UML图：
![](http://yhawaii.github.io/assets/themes/yhawaii/images/DesignPatterns/template_method.png)

### 11.访问者模式(Visitor)

UML图：
![](http://yhawaii.github.io/assets/themes/yhawaii/images/DesignPatterns/visitor.png)
