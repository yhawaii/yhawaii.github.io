---
layout: post
keywords: "Git"
description: "Git基础"
title: "Git基础"
categories: [Git]
tags: [Git]
group: archive
icon: file-alt
---
{% include site/setup %}

相关资料：

[15分钟学会使用Git和远程代码库](http://blog.jobbole.com/53573/)

[官网《Pro Git》](http://git-scm.com/book/zh)

[git - 简易指南](http://rogerdudler.github.io/git-guide/index.zh.html)

##常用git托管平台：

公有代码库[github](https://github.com)

私有代码库[bitbucket](https://bitbucket.org/)

##1.Git 入门
###1.1 近乎所有操作都是本地执行

###1.2 文件的三种状态
1. committed(表示该文件已经被安全保存在本地数据库中)
2.  modified（已经修改了某个文件，单还没有提交保存）
3.  staged(把已修改的文件放在下次提交要保存的清单中)

###1.3 Git目录
每个项目都有一个git目录(如果git clone出来的话，就是.git目录；如果git clone --bare的话，新建的目录本身就是git目录)。
它是git用来保存元数据和对象数据库的地方，该目录非常重要，每次克隆镜像仓库的时候，实际拷贝的就是这个目录里面的数据。

基本的git工作流程：
1. 在工作目录中修改某些文件
2. 对修改后的文件进行快照，然后保存到暂存区域
3. 提交更新，将保存在缓存区域的文件快照永久存储到git目录中。

全新的 git init 生成的 .git目录结构：
	
	HEAD------------------该文件指向当前分支
	branches/-------------历史遗留原因,新版Git不再使用这个目录
	config----------------该文件包含了项目特有的配置选项
	description-----------该文件仅供 GitWeb 程序使用
	hooks/----------------包含了客户端或服务端钩子脚本
	info/-----------------该目录保存了一份不希望在 .gitignore 文件中管理的忽略模式 (ignored patterns) 的全局可执行文件	index-----------------该文件保存了暂存区域信息	objects/--------------该目录存储所有数据内容	refs/-----------------该目录存储指向数据 (分支) 的提交对象的指针	

### 1.4 初次运行Git前的配置
### 用户信息
第一个要配置的是你个人的用户名称和电子邮件地址。这两条配置很重要,每次 Git 提交时都会引用这两 条信息,说明是谁提交了更新,所以会随更新内容一起被永久纳入历史记录:
	
	$ git config --global user.name "John Doe"	$ git config --global user.email johndoe@example.com
	
#### 文本编辑器
设置默认使用的文本剪辑器：
	
	$ git config --global core.editor emacs#### 差异分析工具
设置文件差异比较工具：
	
	 $ git config --global merge.tool vimdiff

#### 查看配置信息：
	
	$ git config -- list

##2.Git 基础

###2.1 获取项目的Git仓库
有两种取得 Git 项目仓库的方法。第一种是在现存的目录下,通过导入所有文件来创建新的 Git 仓库。第 二种是从已有的 Git 仓库克隆出一个新的镜像仓库来。

#### 从当前目录初始化：
初始化命令如下：	
	
	$ git init 

添加远程仓库配置：
	
	$ git remote add origin https://username@github/usernme/first.git

#### 从现有仓库copy

拷贝原有项目：
	
	$ git clone git://github.com/schacon/grit.git
	
项目重命名：

	$ git clone git://github.com/schacon/grit.git newProjectName

Git 支持许多数据传输协议。之前的例子使用的是 git:// 协议,不过你也可以用 http(s):// 或者 user@server:/ path.git 表示的 SSH 传输协议。
###2.2 记录每次更新到仓库
请记住,工作目录下面的所有文件都不外乎这两种状态:已跟踪或未跟踪。已跟踪的文件是指本来就被纳入版本控制管理的文件,在上次快照中有它们的记录,工作一段时间后,它们的状态可能是未更新,已修改或者已放入暂存区。而所有其他文件都属于未跟踪文件。它们既没有上次更新时的快照,也不在当前的暂存区域。初次克隆某个仓库时,工作目录中的所有文件都属于已跟踪文件,且状态为未修改。
#### 检查当前文件的状态
要确定哪些文件当前处于什么状态,可以用 git status 命令
	$ git status 
#### 跟踪新文件
使用命令git add开始跟踪一个新文件。所以,要跟踪 main.c 文件,运行:
	$ git add main.c
#### 暂存已修改文件
	$ git add main.c
#### 忽略某些文件
在你的用户目录下，创建一个 *.gitignore*文件（假如已经存在了，就直接使用之）
下面是*.gitignore*文件内容的示例：
	# 此为注释 – 将被 Git 忽略	*.a # 忽略所有 .a 结尾的文件	!lib.a # 但 lib.a 除外	/TODO # 仅仅忽略项目根目录下的 TODO 文件,不包括 subdir/TODO build/ # 忽略 build/ 目录下的所有文件	doc/*.txt # 会忽略 	doc/notes.txt 但不包括 doc/server/arch.txt
####查看已缓存和未缓存的更新
git status命令的显示比较简单，仅仅是列出了修改过的文件，如果需要查看具体修改了什么地方，可以使用*git diff*命令
	$ git diff 
若要查看已经缓存群里的文件和上次体骄傲时候的快照之间的差异，可以使用 *git diff --staged*命令：
	$ git diff --staged
#### 提交更新（git commit）
现在的暂存区域已经准备妥当可以提交了。在此之前,请一定要确认还有什么修改过的或新建的文件还没有 ***git add*** 过,否则提交的时候不会记录这些还没暂存起来的变化。所以,每次准备提交前,先用 *git status* 看 下,是不是都已暂存起来了,然后再运行提交命令 git commit.
比如进行提交，并且提交时的描述内容为 *test commit*
	$ git commit -m "test commit" 
#### git commit -a
尽管使用暂存区域的方式可以精心准备要提交的细节,但有时候这么做略显繁琐。Git 提供了一个跳过使用 暂存区域的方式,只要在提交的时候,给 git commit 加上 -a 选项,Git 就会自动把所有已经跟踪过的文件暂 存起来一并提交,从而跳过 git add 步骤.
eg:

	$ git commit -a -m "test commit"
#### 移除文件(git rm)
移除main.c文件命令(删除文件)：
	$ git rm main.c
###2.3查看提交历史
####不带任何参数的 *git log* 
查看所有提交历史命令：	$ git log每次更新都有一个 SHA-1 校验和、作者的名字和电子邮件地址、提交时间,最后缩进一个段落显示提交说明。
#### 带 *-p*参数的*git log*
展开显示每次提交的内容差异

	$ git log -p
	
####带*-n*参数的*git log*
查看最近2次的提交历史：

	$ git log -2
	
####带 *--stat*参数的*git log*
显示简要的增改行数统计：
	
	$ git log --stat
	
####带 *--pretty*参数的*git log*

pretty内置关键词oneline,short ,full ,fuller：

	$ git log --pretty=oneline
	
####自定义提交历史显示选项：
	
	$ git log --pretty=format"%d %s"
	
#### since,util关键词
	$ git log --since=2.weeks
	
#### 其它日志显示选项	

	选项 		说明	-p			按补丁格式显示每个更新之间的差异。	--stat 		显示每次更新的文件修改统计信息。	--shortstat 只显示 --stat 中最后的行数修改添加移除统计。	--name-only 仅在提交信息后显示已修改的文件清单。	--name-status 显示新增、修改、删除的文件清单。	--abbrev-commit 仅显示 SHA-1 的前几个字符,而非所有的 40 个字符。	--relative-date 使用较短的相对时间显示(比如,“2 weeks ago”)。	--graph 显示 ASCII 图形表示的分支合并历史。	--pretty 使用其他格式显示历史提交信息。可用的选项包括 oneline,short,full,fuller 和 format(后跟指定格式)。
	
####撤销操作
有时候我们提交完了才发现漏掉了几个文件没有加,或者提交信息写错了。想要撤消刚才的提交操作,可以 使用 --amend 选项重新提交:
	$ git commit --amend
	

###2.4 远程仓库的使用
要参与任何一个 Git 项目的协作,必须要了解该如何管理远程仓库。远程仓库是指托管在网络上的项目仓 库,可能会有好多个,其中有些你只能读,另外有些可以写。同他人协作开发某个项目时,需要管理这些远程 仓库,以便推送或拉取数据,分享各自的工作进展。管理远程仓库的工作,包括添加远程库,移除废弃的远程 库,管理各式远程库分支,定义是否跟踪这些分支,等等#### 查看当前的远程库
	$ git remote
	$ git remote -v
#### 添加远程仓库
git remote add [shortname] [url]:
	$ git remote add pb https://github.com/paulboone/ticgit.git 
	
	# 以后就可以使用pd代表仓库了。
#### 从远程仓库抓取数据
	$ git fetch https://github.com/paulboone/ticgit.git 
	
此命令会到远程仓库中拉取所有你本地仓库中还没有的数据。运行完成后,你就可以在本地访问该远程仓库中的所有分支,将其中某个分支合并到本地,或者只是取出某个分支,一探究竟。可以使用 git pull 命令 自动抓取数据下来,然后将远端分支自动合并到本地仓库中当前分支。在日常工作中我们经常这么用,既快又好。实际上,默认情况下 git clone 命令本质上就是自动创建了本地的 master 分支用于跟踪远程仓库中的 master 分支(假设远程仓库确实有 master 分支)。所以一般我们运行 git pull,目的都是要从原始克隆的远端仓库中抓取数据后,合并到工作目录中当前分支。
	
	$ git pull https://github.com/paulboone/ticgit.git
#### push数据到远程仓库
git push [remote-name] [branch-name]
	
	$ git push origin master
#### 查看远程仓库信息
git remote show [remote-name]

	$ git remote show origin
#### 远程仓库的删除和重命名
重命名:
git remote rename old_name newName
	$ git remote rename pb paul删除 
	$ git remote rm paul
###2.6 打Tag分支
#### 列出已有tag
	$ git tag -l 'v1.1.*'	
其中*-l* 表示以列表形式显示，*'v1.1.*'* 可根据tag名进行匹配
#### 新建含注释的tag
创建一个含附注类型的标签非常简单,用 -a (译注:取 annotated 的首字母)指定标签名字即可:
	$ git tag -a v1.4 -m 'my annotated description'
####  对tag进行签名
如果你有自己的私钥,还可以用 GPG 来签署标签,只需要把之前的 -a 改为 -s (译注: 取 Signed 的首字母)即可:
	$ git tag -s v1.5 -m 'my annotated description'
	
## 附1 设置外部合并与比较工具为P4Merge
首先，下载[P4Merge](http://www.perforce.com/perforce/downloads/component.html)
其次把你要运行的命令放入外部包装脚本中,我会使用Mac系统上的路径来指定该脚本的位置,在其他系统 上, 它应该被放置在二进制文件p4merge所在的目录中。创建一个merge包装脚本,名字叫作extMerge,让它带参 数调用p4merge二进制文件:

	$ cat /usr/local/bin/extMerge	#!/bin/sh /Applications/p4merge.app/Contents/MacOS/p4merge $*
diff包装脚本首先确定传递过来7个参数,随后把其中2个传递给merge包装脚本,默认情况下, Git 传递以 下参数给diff:
	path old-file old-hex old-mode new-file new-hex new-mode
由于你仅仅需要old-file和new-file参数,用diff包装脚本来传递它们吧。
	$ cat /usr/local/bin/extDiff	#!/bin/sh	[ $# -eq 7 ] && /usr/local/bin/extMerge "$2" "$5"
确认这两个脚本是可执行的:
	$ sudo chmod +x /usr/local/bin/extMerge 
	$ sudo chmod +x /usr/local/bin/extDiff
现在来配置使用你自定义的比较和合并工具吧。直接编辑~/.gitconfig文件如下:
	[merge]	tool = extMerge	[mergetool "extMerge"]	cmd = extMerge "$BASE" "$LOCAL" "$REMOTE" "$MERGED" trustExitCode = false	[diff]	external = extDiff
设置完毕后,运行diff命令，就可以看到效果了（启动P4Merge软件GUI，进行比较）:
	$ git diff 32d1776b1^ 32d1776b1
